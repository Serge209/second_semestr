
ЭВМ 1 поколения(ОС пока не существует)
1943 год - балистические таблицы, расчет 4 года.
Джона Мокли и Джона Эккерт - разработали первый компьютер ЭНИАК(электронный дифференциальный анализатор). Скорость одного рачета - 5 минут.
Для перепрограммирования используются перемычки.
Данные вводятся на перфокартах.
Архитектура фон Неймана:
1. Переход к двоичной системе, есть сигнал - 1, не сигнала - 0.
2. Вместо перфокарт данные хранятся в памяти.
3. Память - пронумерованная ячейка для хранения данных.
4. Программы выполняются последовательно.


ЭВМ 2 поколения(первые ЯП)
1. В 50x - годах появились транзисторы. 
2. Высокая надежность транзистеров.
3. Транзистеры не выделяют тепло.
4. Большая скорость переключения.
5. Проблемы соединений транзистеров.
6. Дороговизна транзистеров.
7. Появилтсь алгоритмические языкы: COBOL, ALGOL.
8. Появились комплияторы.
9. Управлющая ЭВМ.
10. Обслуживающая ЭВМ.
11. Программирующая ЭВМ.

ЭВМ 3 и 4 поколения: проблемы:
1. Как разместить все компоненты на полупроводнике?
2. Использование фотолитографии.
3. Как соединить между собой элементы?
4. Напыление алюминия.
5. Автомотическое производство -> уменьшение цены.
6. 60-70 годы: 3 поколение.
7. Увеличилась надежность.
8. Появляются мобильные диски.
9. Мультипрограммирование
10. Разделение времени.
11. 70-80 годы:  4 поколение.
12. Виртуальная память.
13. 1969 - Деннис Ритчи и Кен Томпсон разработали Unix.
14. BSD-UNIX:осбоенности:
15. Виртуальная страничная память.
16. Протоколы TCP/IP.
17. Файловая система FFS.
18. Программа решает хорошо одну задачу.
19. Программы хорошо работают вместе.
20. Программы поддерживают текстовые потоки.

Linux
1. Выделение процессорного времени.
2. Выделение памяти
3. Обработка системных запросов
4. Ввод и ввывод данных

Монолитное ядро(все в одном адресном пространстве)
Микроядро(Каждый процесс как отдельная система)
У микроядра появляется межпроцессорное взаимодействие, но маленькое ядро проще программировать, меньше ошибок, больше надежность системы.

Совместимость ОС - двоичная и на уровне исходных кодов.
Абстракция архитектуры:
1. Пользвательские программы
2. Ядро
3. Ассемблер
4. Микрокод
5. Аппаратное обеспечение.

Файлы unix:
1. Каталоги
2. Сокеты - Со́кет (англ. socket — разъём) — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.

Следует различать клиентские и серверные сокеты. Клиентские сокеты грубо можно сравнить с конечными аппаратами телефонной сети, а серверные — с коммутаторами. Клиентское приложение (например, браузер) использует только клиентские сокеты, а серверное (например, веб-сервер, которому браузер посылает запросы) — как клиентские, так и серверные сокеты.

Интерфейс сокетов впервые появился в BSD Unix. Программный интерфейс сокетов описан в стандарте POSIX.1 и в той или иной мере поддерживается всеми современными операционными системами.
3. Ссылки
4. Именные каналы - В программировании именованный канал или именованный конвейер (англ. named pipe) — один из методов межпроцессного взаимодействия, расширение понятия конвейера в Unix и подобных ОС. Именованный канал позволяет различным процессам обмениваться данными, даже если программы, выполняющиеся в этих процессах, изначально не были написаны для взаимодействия с другими программами. Это понятие также существует и в Microsoft Windows, хотя там его семантика существенно отличается. Традиционный канал — «безымянен», потому что существует анонимно и только во время выполнения процесса. Именованный канал — существует в системе и после завершения процесса. Он должен быть «отсоединён» или удалён, когда уже не используется. Процессы обычно подсоединяются к каналу для осуществления взаимодействия между ними.

5. Символьные устройства - Символьное устройство — (character device) — вид файла устройства в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, с возможностью посимвольного обмена информацией. В отличие от блочного устройства символьное устройство, как правило, не обладает возможностями произвольного доступа. В большинстве своём, чтение и запись данных в символьное устройство не буферизуется. Типичные примеры символьных устройств: стриммер, модем, телетайп или терминал.

6. Блочные устройства - Блочное устройство (block device) — вид файла устройств в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, в виде файла в файловой системе. С блочным устройством обеспечивается обмен данными блоками данных. Как правило, это устройства произвольного доступа, то есть можно указать, из какого именно места должен быть прочитан или записан блок данных. Данные при чтении или записи на блочное устройство буферизуются.
